%\section{結果}
\section{得られた結果}
\subsection{アルゴリズムの開発・改良}
\subsubsection{第一次アルゴリズム}
このアルゴリズムでは完全総当たりの方法を用いた。
具体的には、1つ1つのマスに$1$から$n^2$の数を順に入れていき、全てのマスを埋めたら
正否を判定するというものだ。
最終的に判定される陣数は$(X^2)^{(X^2)}$個である。

このアルゴリズムをプログラム化し、一般のコンピュータで実行したところ、
3次の場合、実行時間が約20秒となった。
このプログラムで4次の場合の計算をすると、式\ref{eqn:prog1-exectime4}より、
実行に約$1.4 \times 10^{12}$秒、つまり約$4.4 \times 10^4$年かかることになる。
よって、4次以上の場合は現実的な時間では実行終了しないので、実際に実行はしなかった。

\begin{equation} \label{eqn:prog1-exectime4}
20 \times ((4^2)^{(4^2)} \div (3^2)^{(3^2)}) \approx 1.4 \times 10^{12}
\end{equation}

また、このアルゴリズムでは$1$から$X^2$の全ての候補をそれぞれのマスに代入しているが、
この場合、最終的に判定される陣に同じ数字が含まれることもある。
これは魔方陣の成立条件に反しており明らかに無駄な処理なので、改善すべきである。


\subsubsection{第二次アルゴリズム}
このアルゴリズムでは第一次アルゴリズムで挙げられた
「陣の中に同じ数字が代入される場合がある」
という点を
解決するために、既に代入されている数字を陣に代入しないようにした。
最終的に判定される陣数は$X^2!$個である。

このアルゴリズムをプログラム化し、一般のコンピュータで実行したところ、
3次の場合、実行時間が約0.17秒となった。
このプログラムで4次の場合の計算をすると、式\ref{eqn:prog1.5-exectime4}より、
実行に約$9.8 \times 10^6$秒、つまり約113日かかることになる。
よって、4次以上の場合は現実的な時間では実行終了しないので、実際に実行はしなかった。

\begin{equation} \label{eqn:prog1.5-exectime4}
0.17 \times (4^2! \div 3^2!) \approx 9.8 \times 10^6
\end{equation}

\subsubsection{第三次アルゴリズム}
このアルゴリズムでは動的計画法を用いた。
具体的には、あらかじめ合計が$L$である要素$X$の数列(正和列と呼ぶ)を作成しておき、
それらの中から$X$個選び、それぞれを陣の横列として代入するというものだ。
正和列は順列で表される。
また、各$X$における正和列の個数$E$を表\ref{tab:ple-each-X}に示す。
最終的に判定される陣数は$_E \mathrm{P} _X$個である。

\begin{table}[htb]
	\begin{center}
	\begin{tabular}{|l|r|}
\hline \hline
\multicolumn{1}{|c|}{$X$} & \multicolumn{1}{|c|}{$E$} \\
\hline \hline
3 & $48$ \\
4 & $2,064$ \\
5 & $167,280$ \\
6 & $23,136,480$ \\
\hline
	\end{tabular}
	\end{center}
	\caption{各$X$における正和列の個数$E$}
	\label{tab:ple-each-X}
\end{table}

このアルゴリズムをプログラム化し、一般のコンピュータで実行したところ、
3次の場合、実行時間が約0.05秒となった。
このプログラムで4次の場合の計算をすると、式\ref{eqn:prog2-exectime4}より
実行に$8.7 \times 10^6$秒、つまり約$101$日かかることになる。
よって、このプログラムも
4次以上の場合は現実的な時間で実行終了しないので、実際に実行はしなかった。

\begin{equation} \label{eqn:prog2-exectime4}
0.05 \times (_{2064} \mathrm{P} _4 \div _{48} \mathrm{P} _3) \approx 8.7 \times 10^6
\end{equation}

\subsubsection{第四次アルゴリズム}
このアルゴリズムでは、第一次アルゴリズムのように陣に数字を埋めていく際、
列中の$X-1$個の数が埋まれば、残りの$1$マスは$L$からそれらの数の合計を引くことにより
求められることを利用した。

さらに今回は、数字を埋める順番を工夫した。
まず初めに斜めのマスを埋め、次にその他のマスを埋めていくというものだ。
その手順を図\ref{pic:prog3-orderofchain}に示す
(丸番号は総当りするマスの順番、
チェックマークは引き算により求められるマスを表している)。
斜めの列上のマスは縦と横だけでなく斜めの列にも属しているので、
それらのマスを優先的に総当たりすれば引き算により求められるマスが増える。

各Xにおける総当たりするマスの個数$A$を表\ref{tab:chaincount-each-X}に示す。
最終的に判定される陣数は高々$_{X^2} \mathrm{P} _A$個である。

\begin{table}[htb]
	\begin{center}
	\begin{tabular}{|l|r|}
\hline \hline
\multicolumn{1}{|c|}{$X$} & \multicolumn{1}{|c|}{$A$} \\
\hline \hline
$3$ & $3$ \\
$4$ & $8$ \\
$5$ & $14$ \\
$6$ & $23$ \\
\hline
	\end{tabular}
	\end{center}
	\caption{各$X$における総当たりするマスの個数$A$}
	\label{tab:chaincount-each-X}
\end{table}

このアルゴリズムをプログラム化し、一般のコンピュータで実行したところ、
実行時間は3次の場合約0.0005秒、4次の場合約0.0012秒、5次の場合約217時間となった。
しかし、
式\ref{eqn:prog4-exectime-3-vs-4-ideal}(3次の場合と4次の場合の理想実行時間の比)・
式\ref{eqn:prog4-exectime-3-vs-4-rhapsody}(3次の場合と4次の場合の実際の実行時間の比)・
式\ref{eqn:prog4-exectime-4-vs-5-ideal}(4次の場合と5次の場合の理想実行時間の比)・
式\ref{eqn:prog4-exectime-4-vs-5-rhapsody}(4次の場合と5次の場合の実際の実行時間の比)・
式\ref{eqn:prog4-exectime-3-vs-5-ideal}(3次の場合と5次の場合の理想実行時間の比)・
式\ref{eqn:prog4-exectime-3-vs-5-rhapsody}(3次の場合と5次の場合の実際の実行時間の比)
よりこの三者の実行時間の比率が正しくないことが分かる。
これは、3次と4次の場合の実行時間がとても短く、
時間計測で誤差が発生してしまったことが原因だと考えられる。

\begin{eqnarray}
\label{eqn:prog4-exectime-3-vs-4-ideal}
_9 \mathrm{P} _3 : _{16} \mathrm{P} _8 & \approx & TMP \\
\label{eqn:prog4-exectime-3-vs-4-rhapsody}
0.0005 : 0.0012 & \approx & TMP \\
\label{eqn:prog4-exectime-4-vs-5-ideal}
 \\
\label{eqn:prog4-exectime-4-vs-5-rhapsody}
0.0012 : 217 \times 60 \times 60 & \approx & TMP \\
\label{eqn:prog4-exectime-3-vs-5-ideal}
TMP \\
\label{eqn:prog4-exectime-3-vs-5-rhapsody}
0.0005 : 217 \times 60 \times 60 & \approx & TMP
\end{eqnarray}

このプログラムは、今までのプログラムでは不可能だった4次や5次の魔方陣の全解を
探求したという面で優秀である。

このプログラムで6次の場合の計算をすると、
5次の実行時間をベースに考えると式\ref{eqn:prog4-exectime-6}より
実行に約秒、つまり約かかることになる。
よって、このプログラムは6次以上の場合、現実的な時間で実行終了しないので、
実際に実行はしなかった。

\begin{equation} \label{eqn:prog4-exectime-6}
(217 \times 60 \times 60) \times (_{36} \mathrm{P} _{23} \div _{25} \mathrm{P} _{14}) \approx 
\end{equation}

また、このプログラムでは、数字が既に代入されているか否かを判断する際に
チェックリストのようなものを使用していた。
しかし、実行の際には「既に代入されているか」ではなく
「どの数字を代入すればよいか」という情報だけを知ればよい。
よって、それに適合している双方向リストをチェックリストの代わりに使用すれば
実行時間がさらに短くなると考えられる。


\subsection{T2K-Tsukuba上での実行}
今回は第三次アルゴリズムのプログラムを5次の場合で並列実行した。
プログラム内並列計算の手順を以下に示す。
\begin{enumerate}
\item マスタが$N$段目($N \in \mathbb{N}, \ N \leq A$)
	まで数字の総当たりをする。
\item そのうちの1つのパターンを1つの暇なワーカに配る。 \label{enum:master-sending}
\item ワーカーがそれを受け取る。 \label{enum:worker-receiving}
\item そのワーカーが$N+1$段目からの数字を総当たりする。
	マスタは手順\ref{enum:master-sending}から繰り返す。
\item ワーカーの1つのパターンに対する処理が終了したら結果をファイルに出力し、
	マスタからのパターン配布を待ち、手順\ref{enum:worker-receiving}から繰り返す。
\item マスタの$N$段目までの総当たり処理が終了したらマスタが全ワーカーに終了を伝え、
実行を終了する。
\end{enumerate}
